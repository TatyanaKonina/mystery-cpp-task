# Parallel Programming. Lab 1. N-body.
**19ПИ-2**
Выполнили:

* Ожиганова Полина
* Конина Татьяна
* Хорошавина Екатерина


## **Run**
```
cd "./mystery-cpp-task/" && g++ task.cpp -o task -lpthread  && "./mystery-cpp-task/"task 300 100 2 test1.txt
```

## **Main idea**
В задаче производится распаралеливание подсчетов новых координат точек в отпределенный момент времени.
У нас есть один общий ресурс с многопоточностью (очередь), чтобы избежать проблем с синхронизацией - были использованы мьютекси и переменные условия.

```[c++]
pthread_mutex_lock(&queuing);
// помещаем задачи в очередь
queuing_jobs = num_body, num_done = 0;
pthread_mutex_unlock(&queuing);
```

```[c++]
void *worker(void *param)
{
    while (true)
    {
        pthread_mutex_lock(&queuing);
        ...
        int i = --queuing_jobs;
        // блокируем критически важную секцию, а именно изменение координат точек
        pthread_mutex_unlock(&queuing);
        ...
        pthread_mutex_lock(&queuing);
        // во время вычисления мы обновляем кол-во задач которые мы выполнили
        num_done++;
        ...
        pthread_mutex_unlock(&queuing);
    }
}
```
При блокировке мьютекса, мы проводим манипуляции с ресурсами, а именно помещаем все задачи в очередь, обновив индексы задач в очереди и счеичик завершенных задач.

Когда очередь задач готова - мы будим все ожидающие потоки с помощью broadcast() и побуждаем их выполнять работу. Далее основной поток должен дождаться завершения всех задач , поэтому он выполняет условие ожидания, а позже будет уведомлен и разбужен, чтобы выполнить последнюю задачу.

```[c++]
for (int i = 0; i < iters; ++i) {
    // есть общий ресурс - очередь задач и мы ее постоянно лочим чтоб никто ее не портил
    pthread_mutex_lock(&queuing);
    ...
    // разбудить всех воркеров
    // чтобы они начали выполнять задачи
    pthread_cond_broadcast(&processing);

    // главный поток будет ждать пока все задачи не будут выполнены
    // позже он будет разбужен последним воркером в этой итерации
    // и таким образом пойдет на новый цикл итераций
    pthread_cond_wait(&iter_fin, &queuing);
    pthread_mutex_unlock(&queuing);
}
```

## **Experiments**

### **2 points**
| threads | dt=300 / iters=100 | dt=150 / iters=100 | dt=500 / iters=250 |
|-------| ---------------| ------------------|----------------------------------|
| 1 | 0.0046 | 0.008 | ⁣0.0152 |
| 2 | ⁣0.0021⁣ ⁣| ⁣0.004 ⁣⁣| ⁣0.011⁣ ⁣|
| 4 | 0.002⁣ ⁣| 0.0054⁣ ⁣| 0.0083⁣ ⁣|
| 8 | 0.003⁣ ⁣| 0.0066 ⁣| ⁣0.0094 ⁣|
| 16 | ⁣0.004 ⁣| 0.0077⁣ ⁣| ⁣0.0149⁣ ⁣|
| 32 | 0.005⁣ ⁣| 0.0092 ⁣| 0.0177⁣ ⁣|

**Charts**

<p align="center">
  <img src="./charts/300-100_2.png" width="650" title="hover text">
</p>

<p align="center">
  <img src="./charts/150-100_2.png" width="650" title="hover text">
</p>

<p align="center">
  <img src="./charts/500-250_2.png" width="650" title="hover text">
</p>

**Conclusion**

Использование блокировки мьютекса для синхронизации потоков и переменных условия отнимает для подсчетов немного времени. Как видно из графиков - оптимальное кол-во потоков для каждого эксперимента было 2. В зависимости от кол-ва итераций - время либо увеличивалось, либо уменьшалось. Так как эксперимент проводился на 2х точках, то при большем кол-ве потоков время увеличивалось и потоки отрабатывали вхолостую.



### **512 points**
| threads | dt=300 / iters=100 | dt=150 / iters=100 | dt=500 / iters=250 | dt=1000 / iters=50 | dt=5 / iters=50 |
|-------| ---------------| ------------------|----------------------------------|----------------------------------|----------------------------------|
| 1 | 14.219 | 38.839 | 107.058 | 3.348 | 3.768 |
| 2 | 14.16⁣ ⁣| 38.831 ⁣⁣| 106.918 ⁣| 3.639 | 3.755  |
| 4 | 14.13⁣ ⁣| 38.751⁣ ⁣| 106.354⁣ ⁣| 3.626 | 3.735 |
| 8 | 14.06⁣ ⁣| 38.649 ⁣| 105.809⁣⁣ ⁣| 3.61 | 3.718 |
| 16 | 13.79 ⁣|⁣ 37.859 ⁣| 104.083 ⁣| 3.569 | 3.49 |
| 32 | 14.309 ⁣| 39.1517 ⁣| 105.66⁣ ⁣| 3.713 | 3.778 |

**Charts**

<p align="center">
  <img src="./charts/100-300_512.png" width="650" title="hover text">
</p>

<p align="center">
  <img src="./charts/100-150_512.png" width="650" title="hover text">
</p>

<p align="center">
  <img src="./charts/250-500_512.png" width="650" title="hover text">
</p>

<p align="center">
  <img src="./charts/50-1000_512.png" width="650" title="hover text">
</p>

<p align="center">
  <img src="./charts/50-5_512.png" width="650" title="hover text">
</p>


**Conclusion**

Использование блокировки мьютекса для синхронизации потоков и переменных условия отнимает для подсчетов немного времени. Как видно из графиков - оптимальное кол-во потоков для каждого эксперимента было 16. В зависимости от кол-ва итераций - время либо увеличивалось, либо уменьшалось.
